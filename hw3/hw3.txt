1)

List all the possible faults

Reduce the list of faults by finding ones that are equivilent and removing the one that is always detected by another fault's test case

Generate test vectors that will make the faulty value differ from it's expected value and have it's result propegate to the primary output

Combine the test vectors that reveal at least 1 unique fault and remove repeating cases to find the minimum tests to detect all faults

######################################################################################################################################

2)

--------------------------------------------------------------------------------------------------------------------------------------
| Fault Location | SA0 (ABCD)                                | SA1 (ABCD)                                                            |
--------------------------------------------------------------------------------------------------------------------------------------
| A              | (1011)/(1111)                             | (0011)/(0111)                                                         |
--------------------------------------------------------------------------------------------------------------------------------------
| B              | (0111)/(1111)                             | (0011)/(1011)                                                         |
--------------------------------------------------------------------------------------------------------------------------------------
| C              | (0011)/(1111)                             | (0001)/(1101)                                                         |
--------------------------------------------------------------------------------------------------------------------------------------
| D              | (0001)/(0101)/(0111)/(1001)/(1011)/(1101) | (0000)/(0100)/(0110)/(1000)/(1010)/(1100)                             |
--------------------------------------------------------------------------------------------------------------------------------------
| n1             | (0111)/(1011)                             | (0011)/(1111)                                                         |
--------------------------------------------------------------------------------------------------------------------------------------
| n2             | (0001)/(1101)                             | (0011)/(1111)                                                         |
--------------------------------------------------------------------------------------------------------------------------------------
| n3             | (0001)/(0101)/(0111)/(1001)/(1011)/(1101) | (0011)/(1111)                                                         |
--------------------------------------------------------------------------------------------------------------------------------------
| Y              | (0001)/(0101)/(0111)/(1001)/(1011)/(1101) | (0000)/(0010)/(0011)/(0100)/(0110)/(1000)/(1010)/(1100)/(1110)/(1111) |
--------------------------------------------------------------------------------------------------------------------------------------

Minimum test vec = {(0000), (0001), (0011), (0111), (1111)}

######################################################################################################################################

3)

0000 = 2 fault cases
0101 = 3 fault cases
1010 = 0 new fault cases
1111 = 6 new fault cases

11/16 cases

11/16 * 100% = 68.75% coverage

######################################################################################################################################

4)

Yes I would agree with my friend. Any digital logic circuit that does not have internal signals that fans out to more than 1 connection
can be fully tested for stuck at faults with the same test vector that tests the input signals for stuck at faults. Every internal signal
is driven by the input values and then propegates to the output meaning that the tests for all the input signals would reveal if an internal
signal were stuck at 1 or 0.
