----------------------------------------------------------------------------------
-- Company : Rochester Institute of Technology (RIT)
-- Engineer : Eden Grace (erg9359@rit.edu)
--
-- Create Date : 10/09/2025
-- Design Name : multiplier
-- Module Name : multiplier - structural
-- Project Name : execute
-- Target Devices : Basys3
--
-- Description : N-bit multiplier using carry-save addition
--               Uses a structural design with a full adder component
--               using partial product generation and carry propagation
--               for faster computation through full adder array
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity multiplier is
	generic (
		N : integer := 32
	);
	port (
		A, B    : in  std_logic_vector(N/2 - 1 downto 0);
		Product : out std_logic_vector(N - 1 downto 0)
	);
end multiplier;

architecture Structural of multiplier is
	type p_array is array (natural range <>) of std_logic_vector(N/2 downto 0);
	signal partial_products : p_array(0 to N/2 - 1) := (others => (others => '0'));
	signal sum_bits : p_array(0 to N/2 - 1) := (others => (others => '0'));
	signal carry_bits : p_array(0 to N/2 - 1) := (others => (others => '0'));
	signal last_cin : std_logic_vector(N/2 downto 0) := (others => '0');

begin

  init_values : for i in 0 to N/2 - 1 generate -- generate initial partial products
		partial_products(0)(i) <= B(i) and A(1);
		sum_bits(0)(i) <= B(i) and A(0);
		carry_bits(0)(i + 1) <= B(i) and A(2);
	end generate init_values;

	sum_bits(1)(N/2) <= carry_bits(0)(N/2); -- set the last b input to the unused c_in value

	Product(0) <= sum_bits(0)(0); -- set first product bit to the first sum calculated

	middle_rows : for i in 0 to N/2 - 3 generate

    next_a : if i > 0 generate -- for all but the first row of adders generate new partial products
			partial_products_gen : for m in 0 to N/2 - 1 generate
        next_b : if m = N/2 - 1 generate -- if i is last partial product
          sum_bits(i + 1)(N/2) <= B(m) and A(i + 2); -- set the partial product to the b input of the last adder of the next row
				end generate next_b;
        next_partial_product : if m < N/2 - 1 generate -- if i is last partial product
          partial_products(i)(m + 1) <= B(m) and A(i + 2); -- calculate partial products
				end generate next_partial_product;
			end generate partial_products_gen;
		end generate next_a;

    adder_gen : for j in 0 to N/2 - 1 generate -- generate the next row of adders and set the c_out to the c_in of the next row of adders
			FA : entity work.fullAdder
				port map(
					A    => partial_products(i)(j),
					B    => sum_bits(i)(j + 1),
					Cin  => carry_bits(i)(j),
					S    => sum_bits(i + 1)(j),
					Cout => carry_bits(i + 1)(j)
				);
		end generate adder_gen;

    Product(i + 1) <= sum_bits(i + 1)(0); -- assign the sum of the first adder in the row generated to the next product bit

	end generate middle_rows;

  ripple_adder_gen : for i in 0 to N/2 - 1 generate -- generate the ripple carry adders to compute the remaining product bits

		FA : entity work.fullAdder
			port map(
				A    => carry_bits(N/2 - 2)(i),
				B    => sum_bits(N/2 - 2)(i + 1),
				Cin  => last_cin(i),
				S    => Product(N/2 - 1 + i),
				Cout => last_cin(i + 1)
			);
	end generate ripple_adder_gen;

	Product(N - 1) <= last_cin(N/2); -- assign the c_out of the last adder to the final Product bit

end Structural;
